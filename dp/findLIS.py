# Наибольшая непрерывная возрастающая последовательность

def findLIS(nums):
    if len(nums) == 0:
        return 0
    if len(nums) == 1:
        return 1
    
    dp = [1] * len(nums)  # Инициализируем массив для хранения длин подпоследовательностей

    for i in range(1, len(nums)):
        if nums[i - 1] < nums[i]:
            dp[i] = dp[i - 1] + 1
    
    return max(dp)

# Тесты
def test_findLIS():
    # Проверяем несколько случаев
    assert findLIS([]) == 0, "Должно быть 0 для пустого списка"
    assert findLIS([1]) == 1, "Должно быть 1 для списка из одного элемента"
    assert findLIS([1, 2, 3, 4]) == 4, "Должно быть 4 для возрастающей последовательности"
    assert findLIS([4, 3, 2, 1]) == 1, "Должно быть 1 для убывающей последовательности"
    assert findLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 3, "Должно быть 3 для смешанной последовательности"

    print("Все тесты пройдены успешно!")

def test_benchmark_findLIS(benchmark):
    # Бенчмарк функции
    benchmark(findLIS, [10, 9, 2, 5, 3, 7, 101, 18] * 1000)  # Измеряем время для большого списка
